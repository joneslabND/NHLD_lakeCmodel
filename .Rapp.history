library(glmtools)
quit()
library(Rgtk2)
library(RGtk2)
remove.packages(RGtk2)
remove.packages('RGtk2')
library("RGtk2")
remove.packages('RGtk2')
(1.6-1)/1
(1.6543-1.0423)/1.0423
15*40*50
15*40*25
15*40*25*1.48
x=seq(1,200)
1/0.69
1/.13
15872*(55000/(9728+55000))
15872*(55000/(9728+55000))+55000
(10250+388)/68486.59
(10250+388)/68486.59*12
10250+388
10250+388*6
10638*6
10250+388
10638*2
15872*(55000/(55000+9728))
13486.59+55000
21276/68486.59
1864.39+357.76
p=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)
Vp
Ve
Ve*0.2
##### Simplest CH4 ecosystem model#
##### 11-5-14#
##### WEW & SEJ#
#
rm(list=ls())#
#
library(deSolve)#
#
# set up ordinary differential equations (ODEs) in function for deSolve to use for each time step#
#
# State variables:#
#		1. CH4 in profundal sediment#
#		2. CH4 in littoral sediment#
#		3. CH4 in epilimnion#
#
# Daily time step#
#
timeStepCH4<-function(times,y,params){#
	with(as.list(params){#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	})#
}#
#
# Parameters#
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)#
#
init=c(0.2*Vp,0.2*Vl,0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
timeStepCH4<-function(times,y,params){#
	with(as.list(params){#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	)}#
}
timeStepCH4<-function(times,y,params){#
	with(as.list(params){#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	})#
}
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	})#
}
rm(list=ls())#
#
library(deSolve)#
#
# set up ordinary differential equations (ODEs) in function for deSolve to use for each time step#
#
# State variables:#
#		1. CH4 in profundal sediment#
#		2. CH4 in littoral sediment#
#		3. CH4 in epilimnion#
#
# Daily time step#
#
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	})#
}
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)#
#
init=c(0.2*Vp,0.2*Vl,0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris
out=ode(y=init,times=t.s,func=timeSt,parms=params)
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris #
atmCH4=0.1	# [mol CH4 m-3]
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris --> Stuart will remember how to do this dynamically#
atmCH4=0.1	# [mol CH4 m-3]Will thinks this is about right --> We can check this and use whatever the global average is
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
dPdt=5
dLdt=2
dEdt=1
list(dPdt,dLdt,dEdt)
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
		return(list(dP.dt,dL.dt,dE.dt))#
	})#
}
# Parameters#
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)#
#
init=c(0.2*Vp,0.2*Vl,0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris --> Stuart will remember how to do this dynamically#
atmCH4=0.1	# [mol CH4 m-3]Will thinks this is about right --> We can check this and use whatever the global average is
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
init=c(0.2*Vp,0.2*Vl,0.2*Ve)
length(init)
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
		return(as.list(c(dP.dt,dL.dt,dE.dt)))#
	})#
}
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
		list(c(dP.dt,dL.dt,dE.dt))#
	})#
}
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)
init=c(0.2*Vp,0.2*Vl,0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris --> Stuart will remember how to do this dynamically#
atmCH4=0.1	# [mol CH4 m-3]Will thinks this is about right --> We can check this and use whatever the global average is#
#
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
dim(out)
head(out)
init=c(P=0.2*Vp,L=0.2*Vl,E=0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris --> Stuart will remember how to do this dynamically#
atmCH4=0.1	# [mol CH4 m-3]Will thinks this is about right --> We can check this and use whatever the global average is#
#
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
head(out)
dev.new()#
par(mfrow=c(3,1))#
plot(out[,1],out[,2],type='l',lwd=2,xlab="Time",ylab="Profundal CH4")#
plot(out[,1],out[,3],type='l',lwd=2,xlab="Time",ylab="Littoral CH4",col='red')#
plot(out[,1],out[,4],type='l',lwd=2,xlab="Time",ylab="Epilimnion CH4",col='green')
dim(out)
out[180,]
65.366/Ve
65.366/Ve*1000
DecayVector <- c(0.05,0.12,0.14,0.05,0.06,0.09,0.05,0.14,0.15)#
TempVector <- c(5,20,35,5,20,35,5,20,35)#
UVBVector <- c(2,25,50,25,2,2,50,50,25)#
StricklerFig4pH10 <- data.frame(Decay=DecayVector, Temp=TempVector, UVB=UVBVector)#
#
# Fit the model (including all interactions) using lm#
model=lm(Decay~Temp*UVB,StricklerFig4pH10)#
summary(model) #
par(mfrow=c(2,2)) #
plot(model)
DecayVector <- c(0.05,0.12,0.14,0.05,0.06,0.09,0.05,0.14,0.15)#
TempVector <- c(5,20,35,5,20,35,5,20,35)#
UVBVector <- c(2,25,50,25,2,2,50,50,25)#
StricklerFig4pH10 <- data.frame(Decay=DecayVector, Temp=TempVector, UVB=UVBVector)#
#
# Fit the model (including all interactions) using lm#
model=lm(Decay~Temp+UVB,StricklerFig4pH10)#
summary(model) #
par(mfrow=c(2,2)) #
plot(model)
DecayVector <- c(0.05,0.12,0.14,0.05,0.06,0.09,0.05,0.14,0.15)#
TempVector <- c(5,20,35,5,20,35,5,20,35)#
UVBVector <- c(2,25,50,25,2,2,50,50,25)#
StricklerFig4pH10 <- data.frame(Decay=DecayVector, Temp=TempVector, UVB=UVBVector)#
#
# Fit the model (including all interactions) using lm#
model=lm(Decay~Temp,StricklerFig4pH10)#
summary(model) #
par(mfrow=c(2,2)) #
plot(model)
exp(2)
x=5
y=2
z=matrix(NA,10,10)
ls9)
ls()
str(ls())
str(x)
str(y)
str(z)
students=c(#
"Amanda",#
"Maggie",#
"Martha",#
"Margaret",#
"Meredith",#
"Brandon",#
"Julia",#
"Pete",#
"Lainey",#
"Michael",#
"Toby"#
)
length(students)
sample(students,length(students),replace=FALSE)
file.choose()
choose.file()
?sum
?c
v=c(1,2,3,20)
v
v=1:4
v
rm(list=ls())
1:4
v
v=1:4
v
v=seq(from=2,to=24,by=2)
v
?seq
b=seq(to=4)
b
b=seq(from=4)
b
rep(2,5)
v
length(v)
max(v)
min(v)
range(v)
rangeofv=range(v)
length(rangeofv)
length(range(v))
v
v>6
A=matrix(0,nrow=2,ncol=2)
A
A=matrix(1:4,nrow=2,ncol=2)
A
dim(A)
nrow(A)
length(A)
t(A)
a=list(name="walleye",length=225,tagged=TRUE)
a
a$name
a$length
names=c("walleye","perch")
weight=c(270,57)
d=data.frame(names=names,weight=weigth,stringsAsFactors=FALSE)
d=data.frame(names=names,weight=weight,stringsAsFactors=FALSE)
d
d[1,1]
d[,1]
d$names
students=c(#
"Amanda",#
"Maggie",#
"Martha",#
"Meg",#
"Meredith",#
"Brandon",#
"Julia",#
"Peter",#
"Lainey",#
"Mike",#
"Toby"#
)#
#
sample(students,length(students),replace=FALSE)
t=1:180#
#
a=0.5#
b=1#
c=-0.5
plot(t,a+b*exp(c),type='l')
plot(t,a+b*exp(c*t),type='l')
?glm
?guassian
?gaussian
?glm
?gaussian
88633*1.609
87975/91089.32
87975*1.035
(91089.32-87975)/87975
250*12
87975*0.035
91000*1.03
91000*1.03^3
91000*1.03^4
require("deSolve")
persistCannibalism<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=Ba*(C*Va)/(C+Ka)*Ea-Ba*da		#g (L*day)^-1#
		dCdt=Ba*da*m-Ba*(C*Va)/(C+Ka)		#g (L*day)^-1#
		res=c(dBadt,dCdt)#
		list(res)#
	})#
}
parms = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, m=0.5)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02, C = 0)#
#
outPC=ode(y=init,times=times,func=persistCannibalism,parms=parms)#
#
dev.new()#
par(mfrow=c(2,1))#
plot(outPC[,1],log10(outPC[,2]/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPC[,1],outPC[,3],type='l',xlab='time',ylab='carbon (g)')
persist<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=-Ba*da		#g (L*day)^-1#
		res(c(dBadt))#
		list(res)#
	})#
}
parms = c(da = 0.1)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02)
persist<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=-Ba*da		#g (L*day)^-1#
		res(c(dBadt))#
		list(res)#
	})#
}#
#
#parameters#
# da= mortality rate [day^-1]#
#
# assumptions#
# 20e-15 g (femtograms of C per cell)#
# start with 1e12 cells per L (0.02 g C in Ba)#
#
parms = c(da = 0.1)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02)#
#
outP=ode(y=init,times=times,func=persist,parms=parms)
persist<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=-Ba*da		#g (L*day)^-1#
		res=c(dBadt)#
		list(res)#
	})#
}
parms = c(da = 0.1)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02)#
#
outP=ode(y=init,times=times,func=persist,parms=parms)
dev.new()#
plot(outP[,1],log10(outP[,2]/(20e-15)),xlab="time",ylab="log10 cells",type='l')
# population decay without evolution, but C recycling#
persistCannibalism<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=Ba*(C*Va)/(C+Ka)*Ea-Ba*da		#g (L*day)^-1#
		dCdt=Ba*da*m-Ba*(C*Va)/(C+Ka)		#g (L*day)^-1#
		res=c(dBadt,dCdt)#
		list(res)#
	})#
}#
#
# parameters#
# Va= mass-specific maximum uptake rate [g (g*day)^-1]#
# Ka= carbon half-saturation constant [g L^-1]#
# Ea= growth efficiency#
# da= mortality rate [day^-1]#
# m= fraction of dead bacteria available for consumption#
#
# assumptions#
# 20e-15 g (femtograms of C per cell)#
# start with 1e12 cells per L (0.02 g C in Ba)#
#
# Apsergillus niger??? Ka=15 uM glucose, Va=1 umol (gram dry weight)^-1 second^-1 Jorgensen et al. 2007 Microbiology, 153: 1963-1973#
					#  Ka=0.0011 g C L^-1; Va=12.4 g C (g bacterial C)^-1 day^-1#
#
#parms = c(Va = 10^-10, Ka = 10^-10, Ea = 0.75, da = 0.1, m=0.5) # these are from Jay's old script#
parms = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, m=0.5)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02, C = 0)#
#
outPC=ode(y=init,times=times,func=persistCannibalism,parms=parms)#
#
dev.new()#
par(mfrow=c(2,1))#
plot(outPC[,1],log10(outPC[,2]/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPC[,1],outPC[,3],type='l',xlab='time',ylab='carbon (g)')
persistCannibalismMut<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=Ba*(C*Va)/(C+Ka)*Ea-Ba*da#
		dBmdt=Bm*(C*Vm)/(C+Km)*Em-Bm*dm#
		dCdt=Ba*da*m-Ba*(C*Va)/(C+Ka)+Bm*dm*m-Bm*(C*Vm)/(C+Km)#
		res=c(dBadt,dBmdt,dCdt)#
		list(res)#
	})#
}#
# simulate with lower death rate in mutant#
#
# fraction of initial population that are mutant#
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=12, Km=0.0011, Em=0.75, dm=0.05, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics
dev.new()#
par(mfrow=c(2,2))#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 cells",type='l')
par(mfrow=c(2,3))#
plot(outPCmut[,1],rowSums(outPCmut[,2:3]),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)',type="l")
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)',type="l")
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 0, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=0, Km=0.0011, Em=0.75, dm=0.05, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=12, Km=0.0011, Em=0.75, dm=0.05, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=12, Km=0.0011, Em=0.8, dm=0.1, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=12, Km=0.0011, Em=0.9, dm=0.1, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.5, da = 0.1, Vm=12, Km=0.0011, Em=0.9, dm=0.1, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.5, da = 0.1, Vm=12, Km=0.0011, Em=0.9, dm=0.05, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
rm(list=ls())#
#
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/NHLD_lakeCmodel")#
#
########## load utility functions and packages#
source("nhldWatershedModel_onlyHydro_dynRechargeSupporting.R")#
require(deSolve)#
require(LakeMetabolizer)#
#
######## load forcing and flux data#
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/VICforcings&output/PROC")#
#
cells=gsub("FLUX_","",grep("FLUX",list.files(),value=TRUE))#
#
forceFiles=grep("FORCE",list.files(),value=TRUE)#
fluxFiles=grep("FLUX",list.files(),value=TRUE)#
#
#### UNDERC includes four VIC cells#
# 46.28125_-89.53125#
# 46.28125_-89.46875#
# 46.21875_-89.53125#
# 46.21875_-89.46875#
UNDERCcells=cells[c(169,170,182,183)]#
#
# Lat Long Year Month Day Runoff_mmDay Precip_mmDay EvapOpenWater_mmDay#
flux=read.table(paste("FLUX_",UNDERCcells[1],sep=""),header=FALSE)#
# Lat Long Year Month Day Hour NetLW_Wm2 NetSW_Wm2 LW_Wm2 SW_Wm2 AirTemp_dC atmPress_kPa windspeed_mS@10m relHumid_fraction#
force=read.table(paste("FORCE_",UNDERCcells[1],sep=""),header=FALSE)#
#
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/NHLD_lakeCmodel")#
# Year Month Day NetRecharge_mmDay#
recharge=read.table("meanRechargeTS.txt",header=FALSE,sep="\t",stringsAsFactors=FALSE)#
#
# starting year/month/day, ending year/mnth/day, & set up force/flux#
startYear=2010#
startMonth=1#
startDay=1#
#
endYear=2013#
endMonth=12#
endDay=31#
#
curForce=force[which(((force[,3]==startYear) & (force[,4]==startMonth) & (force[,5]==startDay) & (force[,6]==0))):which(((force[,3]==endYear) & (force[,4]==endMonth) & (force[,5]==endDay) & (force[,6]==23))),]#
#
curFlux=flux[which(((flux[,3]==startYear) & (flux[,4]==startMonth) & (flux[,5]==startDay))):which(((flux[,3]==endYear) & (flux[,4]==endMonth) & (flux[,5]==endDay))),]#
#
curRecharge=recharge[which(((recharge[,1]==startYear) & (recharge[,2]==startMonth) & (recharge[,3]==startDay))):which(((recharge[,1]==endYear) & (recharge[,2]==endMonth) & (recharge[,3]==endDay))),]#
#
curFluxDOY=1:nrow(curFlux)#
curForceDOY=rep(curFluxDOY,each=24)#
#
###### forcing functions#
dailyPrecip=approxfun(curFluxDOY,curFlux[,7],method="constant")#
dailyEvap=approxfun(curFluxDOY,curFlux[,8],method="constant")#
dailyRunoff=approxfun(curFluxDOY,curFlux[,6],method="constant")#
#
####### ice cover: using regressions from Finland ()#
# -> alternative: try looking at NTL data...; fit model with degree days?#
#
###***** this stuff will have troubles if ice on happens after january 1 ******####
aprilForce=force[force[,4]==4,]#
novForce=force[force[,4]==11,]#
#
aprilAT=tapply(aprilForce[,11],aprilForce[,3],FUN=mean)#
novAT=tapply(novForce[,11],novForce[3],FUN=mean)#
#
iceOnDOY=(novAT+28.8)/0.19+182	#equation for November from inland North -> has latest ice on; pick this one because study area much higher N#
#
iceOffDOY=(aprilAT-49.7)/-0.16+182-365	#Coastal/South model for breakup; again earliest date, but want this bias...#
#
iceON=numeric(nrow(curFlux))#
years=sort(unique(curFlux[,3]))#
for(j in 1:length(years)){#
	curYear=curFlux[curFlux[,3]==years[j],]#
	curDOY=as.numeric(strftime(strptime(paste(curYear[,3],curYear[,4],curYear[,5],sep="-"),format="%Y-%m-%d"),format="%j"))#
	iceON[curFlux[,3]==years[j]]=((curDOY<iceOffDOY[names(iceOffDOY)==years[j]]) | (curDOY>iceOnDOY[names(iceOnDOY)==years[j]]))*1#
}#
#
####### load lake/watershed information#
UNDERCsheds=read.table("../NHLDwatershedDelineations/UNDERCsheds_4-24-15.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
#
GFLOWoutput=read.table("../gflowOutput/gflowSensitivity_5-21-15/NHLD_GFLOW_UNDERC_20150520_Simplify010_RegK1_LocK0pt01_OutputLong.txt",header=TRUE,stringsAsFactors=FALSE)#
colnames(GFLOWoutput)[1]="Permanent_"#
#
gwIn_fRecharge=read.table("gwIn_fRecharge.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
gwOut_fRecharge=read.table("gwOut_fRecharge.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
i=17
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curgwCoefIn=gwIn_fRecharge[gwIn_fRecharge[,1]==curLakeID,]#
curgwCoefOut=gwOut_fRecharge[gwOut_fRecharge[,1]==curLakeID,]#
#
gwIn0=(curRecharge[,4]*curgwCoefIn[1,4]+curgwCoefIn[1,3])*0.0283168	#m3 d-1#
gwOut0=(curRecharge[,4]*curgwCoefOut[1,4]+curgwCoefOut[1,3])*0.0283168	#m3 d-1#
#
gwIn0[curRecharge[,4]<=curgwCoefIn[1,2]]=0#
gwOut0[curRecharge[,4]>=curgwCoefOut[1,2]]=0
range(gwIn0)
range(gwOut0)
sum(gwIn0!=0)
range(gwIn0[gwIn0!=0])
i=4
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curgwCoefIn=gwIn_fRecharge[gwIn_fRecharge[,1]==curLakeID,]#
curgwCoefOut=gwOut_fRecharge[gwOut_fRecharge[,1]==curLakeID,]#
#
gwIn0=(curRecharge[,4]*curgwCoefIn[1,4]+curgwCoefIn[1,3])*0.0283168	#m3 d-1#
gwOut0=(curRecharge[,4]*curgwCoefOut[1,4]+curgwCoefOut[1,3])*0.0283168	#m3 d-1#
#
gwIn0[curRecharge[,4]<=curgwCoefIn[1,2]]=0#
gwOut0[curRecharge[,4]>=curgwCoefOut[1,2]]=0
range(gwIn0)
gwIn0[gwIn0<0]=0#
gwOut0[gwOut0<0]=0
daily_gwIn0=approxfun(curFluxDOY,gwIn0)#
daily_gwOut0=approxfun(curFluxDOY,gwOut0)#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,daily_gwIn0(out[,1])*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),daily_gwOut0(out[,1])*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
i
i=17
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curgwCoefIn=gwIn_fRecharge[gwIn_fRecharge[,1]==curLakeID,]#
curgwCoefOut=gwOut_fRecharge[gwOut_fRecharge[,1]==curLakeID,]#
#
gwIn0=(curRecharge[,4]*curgwCoefIn[1,4]+curgwCoefIn[1,3])*0.0283168	#m3 d-1#
gwOut0=(curRecharge[,4]*curgwCoefOut[1,4]+curgwCoefOut[1,3])*0.0283168	#m3 d-1#
#
gwIn0[curRecharge[,4]<=curgwCoefIn[1,2]]=0#
gwOut0[curRecharge[,4]>=curgwCoefOut[1,2]]=0
range(gwIn0)
range(gwOut0)
gwIn0[gwIn0<0]=0#
gwOut0[gwOut0<0]=0
daily_gwIn0=approxfun(curFluxDOY,gwIn0)#
daily_gwOut0=approxfun(curFluxDOY,gwOut0)#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,daily_gwIn0(out[,1])*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),daily_gwOut0(out[,1])*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
# starting year/month/day, ending year/mnth/day, & set up force/flux#
startYear=1985#
startMonth=1#
startDay=1#
#
endYear=2013#
endMonth=12#
endDay=31#
#
curForce=force[which(((force[,3]==startYear) & (force[,4]==startMonth) & (force[,5]==startDay) & (force[,6]==0))):which(((force[,3]==endYear) & (force[,4]==endMonth) & (force[,5]==endDay) & (force[,6]==23))),]#
#
curFlux=flux[which(((flux[,3]==startYear) & (flux[,4]==startMonth) & (flux[,5]==startDay))):which(((flux[,3]==endYear) & (flux[,4]==endMonth) & (flux[,5]==endDay))),]#
#
curRecharge=recharge[which(((recharge[,1]==startYear) & (recharge[,2]==startMonth) & (recharge[,3]==startDay))):which(((recharge[,1]==endYear) & (recharge[,2]==endMonth) & (recharge[,3]==endDay))),]#
#
curFluxDOY=1:nrow(curFlux)#
curForceDOY=rep(curFluxDOY,each=24)#
#
###### forcing functions#
dailyPrecip=approxfun(curFluxDOY,curFlux[,7],method="constant")#
dailyEvap=approxfun(curFluxDOY,curFlux[,8],method="constant")#
dailyRunoff=approxfun(curFluxDOY,curFlux[,6],method="constant")#
#
####### ice cover: using regressions from Finland ()#
# -> alternative: try looking at NTL data...; fit model with degree days?#
#
###***** this stuff will have troubles if ice on happens after january 1 ******####
aprilForce=force[force[,4]==4,]#
novForce=force[force[,4]==11,]#
#
aprilAT=tapply(aprilForce[,11],aprilForce[,3],FUN=mean)#
novAT=tapply(novForce[,11],novForce[3],FUN=mean)#
#
iceOnDOY=(novAT+28.8)/0.19+182	#equation for November from inland North -> has latest ice on; pick this one because study area much higher N#
#
iceOffDOY=(aprilAT-49.7)/-0.16+182-365	#Coastal/South model for breakup; again earliest date, but want this bias...#
#
iceON=numeric(nrow(curFlux))#
years=sort(unique(curFlux[,3]))#
for(j in 1:length(years)){#
	curYear=curFlux[curFlux[,3]==years[j],]#
	curDOY=as.numeric(strftime(strptime(paste(curYear[,3],curYear[,4],curYear[,5],sep="-"),format="%Y-%m-%d"),format="%j"))#
	iceON[curFlux[,3]==years[j]]=((curDOY<iceOffDOY[names(iceOffDOY)==years[j]]) | (curDOY>iceOnDOY[names(iceOnDOY)==years[j]]))*1#
}#
#
####### load lake/watershed information#
UNDERCsheds=read.table("../NHLDwatershedDelineations/UNDERCsheds_4-24-15.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
#
GFLOWoutput=read.table("../gflowOutput/gflowSensitivity_5-21-15/NHLD_GFLOW_UNDERC_20150520_Simplify010_RegK1_LocK0pt01_OutputLong.txt",header=TRUE,stringsAsFactors=FALSE)#
colnames(GFLOWoutput)[1]="Permanent_"#
#
gwIn_fRecharge=read.table("gwIn_fRecharge.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
gwOut_fRecharge=read.table("gwOut_fRecharge.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
i
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curgwCoefIn=gwIn_fRecharge[gwIn_fRecharge[,1]==curLakeID,]#
curgwCoefOut=gwOut_fRecharge[gwOut_fRecharge[,1]==curLakeID,]#
#
gwIn0=(curRecharge[,4]*curgwCoefIn[1,4]+curgwCoefIn[1,3])*0.0283168	#m3 d-1#
gwOut0=(curRecharge[,4]*curgwCoefOut[1,4]+curgwCoefOut[1,3])*0.0283168	#m3 d-1#
#
gwIn0[curRecharge[,4]<=curgwCoefIn[1,2]]=0#
gwOut0[curRecharge[,4]>=curgwCoefOut[1,2]]=0#
#
gwIn0[gwIn0<0]=0#
gwOut0[gwOut0<0]=0#
#
daily_gwIn0=approxfun(curFluxDOY,gwIn0)#
daily_gwOut0=approxfun(curFluxDOY,gwOut0)#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
dim(out)
length(fluxDOY)
length(times)
plot(out[,1],out[,2],type='l')
daily_gwIn0=approxfun(curFluxDOY,gwIn0,method="constant")#
daily_gwOut0=approxfun(curFluxDOY,gwOut0,method="constant")
i
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curgwCoefIn=gwIn_fRecharge[gwIn_fRecharge[,1]==curLakeID,]#
curgwCoefOut=gwOut_fRecharge[gwOut_fRecharge[,1]==curLakeID,]#
#
gwIn0=(curRecharge[,4]*curgwCoefIn[1,4]+curgwCoefIn[1,3])*0.0283168	#m3 d-1#
gwOut0=(curRecharge[,4]*curgwCoefOut[1,4]+curgwCoefOut[1,3])*0.0283168	#m3 d-1#
#
gwIn0[curRecharge[,4]<=curgwCoefIn[1,2]]=0#
gwOut0[curRecharge[,4]>=curgwCoefOut[1,2]]=0#
#
gwIn0[gwIn0<0]=0#
gwOut0[gwOut0<0]=0#
#
daily_gwIn0=approxfun(curFluxDOY,gwIn0,method="constant")#
daily_gwOut0=approxfun(curFluxDOY,gwOut0,method="constant")#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY
source("nhldWatershedModel_onlyHydro_dynRechargeSupporting.R")
source("nhldWatershedModel_onlyHydro_dynRechargeSupporting.R")
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
dim(out)
?ode
out<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")
startYear=2008
curForce=force[which(((force[,3]==startYear) & (force[,4]==startMonth) & (force[,5]==startDay) & (force[,6]==0))):which(((force[,3]==endYear) & (force[,4]==endMonth) & (force[,5]==endDay) & (force[,6]==23))),]#
#
curFlux=flux[which(((flux[,3]==startYear) & (flux[,4]==startMonth) & (flux[,5]==startDay))):which(((flux[,3]==endYear) & (flux[,4]==endMonth) & (flux[,5]==endDay))),]#
#
curRecharge=recharge[which(((recharge[,1]==startYear) & (recharge[,2]==startMonth) & (recharge[,3]==startDay))):which(((recharge[,1]==endYear) & (recharge[,2]==endMonth) & (recharge[,3]==endDay))),]#
#
curFluxDOY=1:nrow(curFlux)#
curForceDOY=rep(curFluxDOY,each=24)#
#
###### forcing functions#
dailyPrecip=approxfun(curFluxDOY,curFlux[,7],method="constant")#
dailyEvap=approxfun(curFluxDOY,curFlux[,8],method="constant")#
dailyRunoff=approxfun(curFluxDOY,curFlux[,6],method="constant")#
#
####### ice cover: using regressions from Finland ()#
# -> alternative: try looking at NTL data...; fit model with degree days?#
#
###***** this stuff will have troubles if ice on happens after january 1 ******####
aprilForce=force[force[,4]==4,]#
novForce=force[force[,4]==11,]#
#
aprilAT=tapply(aprilForce[,11],aprilForce[,3],FUN=mean)#
novAT=tapply(novForce[,11],novForce[3],FUN=mean)#
#
iceOnDOY=(novAT+28.8)/0.19+182	#equation for November from inland North -> has latest ice on; pick this one because study area much higher N#
#
iceOffDOY=(aprilAT-49.7)/-0.16+182-365	#Coastal/South model for breakup; again earliest date, but want this bias...#
#
iceON=numeric(nrow(curFlux))#
years=sort(unique(curFlux[,3]))#
for(j in 1:length(years)){#
	curYear=curFlux[curFlux[,3]==years[j],]#
	curDOY=as.numeric(strftime(strptime(paste(curYear[,3],curYear[,4],curYear[,5],sep="-"),format="%Y-%m-%d"),format="%j"))#
	iceON[curFlux[,3]==years[j]]=((curDOY<iceOffDOY[names(iceOffDOY)==years[j]]) | (curDOY>iceOnDOY[names(iceOnDOY)==years[j]]))*1#
}#
#
####### load lake/watershed information#
UNDERCsheds=read.table("../NHLDwatershedDelineations/UNDERCsheds_4-24-15.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
#
GFLOWoutput=read.table("../gflowOutput/gflowSensitivity_5-21-15/NHLD_GFLOW_UNDERC_20150520_Simplify010_RegK1_LocK0pt01_OutputLong.txt",header=TRUE,stringsAsFactors=FALSE)#
colnames(GFLOWoutput)[1]="Permanent_"#
#
gwIn_fRecharge=read.table("gwIn_fRecharge.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
gwOut_fRecharge=read.table("gwOut_fRecharge.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
i=17
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curgwCoefIn=gwIn_fRecharge[gwIn_fRecharge[,1]==curLakeID,]#
curgwCoefOut=gwOut_fRecharge[gwOut_fRecharge[,1]==curLakeID,]#
#
gwIn0=(curRecharge[,4]*curgwCoefIn[1,4]+curgwCoefIn[1,3])*0.0283168	#m3 d-1#
gwOut0=(curRecharge[,4]*curgwCoefOut[1,4]+curgwCoefOut[1,3])*0.0283168	#m3 d-1#
#
gwIn0[curRecharge[,4]<=curgwCoefIn[1,2]]=0#
gwOut0[curRecharge[,4]>=curgwCoefOut[1,2]]=0#
#
gwIn0[gwIn0<0]=0#
gwOut0[gwOut0<0]=0#
#
daily_gwIn0=approxfun(curFluxDOY,gwIn0,method="constant")#
daily_gwOut0=approxfun(curFluxDOY,gwOut0,method="constant")#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY
system.time(out<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")#
)
system.time(out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
)
outSODA=out
outRK<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")
system.time(outEULER<-ode(y=initialX,times=times,func=timeStep,parms=params,method="euler")#
)
dim(outSODA)
dim(outRK)
dim(outEULER)
plot(outSODA[,2],outRK[,2])
plot(log10(outSODA[,2]),log10(outRK[,2]))
plot(log10(outSODA[,2]),log10(outEULER[,2]))
plot(log10(outRK[,2]),log10(outEULER[,2]))
startYear=1985#
startMonth=1#
startDay=1#
#
endYear=2013#
endMonth=12#
endDay=31#
#
curForce=force[which(((force[,3]==startYear) & (force[,4]==startMonth) & (force[,5]==startDay) & (force[,6]==0))):which(((force[,3]==endYear) & (force[,4]==endMonth) & (force[,5]==endDay) & (force[,6]==23))),]#
#
curFlux=flux[which(((flux[,3]==startYear) & (flux[,4]==startMonth) & (flux[,5]==startDay))):which(((flux[,3]==endYear) & (flux[,4]==endMonth) & (flux[,5]==endDay))),]#
#
curRecharge=recharge[which(((recharge[,1]==startYear) & (recharge[,2]==startMonth) & (recharge[,3]==startDay))):which(((recharge[,1]==endYear) & (recharge[,2]==endMonth) & (recharge[,3]==endDay))),]#
#
curFluxDOY=1:nrow(curFlux)#
curForceDOY=rep(curFluxDOY,each=24)#
#
###### forcing functions#
dailyPrecip=approxfun(curFluxDOY,curFlux[,7],method="constant")#
dailyEvap=approxfun(curFluxDOY,curFlux[,8],method="constant")#
dailyRunoff=approxfun(curFluxDOY,curFlux[,6],method="constant")#
#
####### ice cover: using regressions from Finland ()#
# -> alternative: try looking at NTL data...; fit model with degree days?#
#
###***** this stuff will have troubles if ice on happens after january 1 ******####
aprilForce=force[force[,4]==4,]#
novForce=force[force[,4]==11,]#
#
aprilAT=tapply(aprilForce[,11],aprilForce[,3],FUN=mean)#
novAT=tapply(novForce[,11],novForce[3],FUN=mean)#
#
iceOnDOY=(novAT+28.8)/0.19+182	#equation for November from inland North -> has latest ice on; pick this one because study area much higher N#
#
iceOffDOY=(aprilAT-49.7)/-0.16+182-365	#Coastal/South model for breakup; again earliest date, but want this bias...#
#
iceON=numeric(nrow(curFlux))#
years=sort(unique(curFlux[,3]))#
for(j in 1:length(years)){#
	curYear=curFlux[curFlux[,3]==years[j],]#
	curDOY=as.numeric(strftime(strptime(paste(curYear[,3],curYear[,4],curYear[,5],sep="-"),format="%Y-%m-%d"),format="%j"))#
	iceON[curFlux[,3]==years[j]]=((curDOY<iceOffDOY[names(iceOffDOY)==years[j]]) | (curDOY>iceOnDOY[names(iceOnDOY)==years[j]]))*1#
}#
#
####### load lake/watershed information#
UNDERCsheds=read.table("../NHLDwatershedDelineations/UNDERCsheds_4-24-15.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
#
GFLOWoutput=read.table("../gflowOutput/gflowSensitivity_5-21-15/NHLD_GFLOW_UNDERC_20150520_Simplify010_RegK1_LocK0pt01_OutputLong.txt",header=TRUE,stringsAsFactors=FALSE)#
colnames(GFLOWoutput)[1]="Permanent_"#
#
gwIn_fRecharge=read.table("gwIn_fRecharge.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
gwOut_fRecharge=read.table("gwOut_fRecharge.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
i
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curgwCoefIn=gwIn_fRecharge[gwIn_fRecharge[,1]==curLakeID,]#
curgwCoefOut=gwOut_fRecharge[gwOut_fRecharge[,1]==curLakeID,]#
#
gwIn0=(curRecharge[,4]*curgwCoefIn[1,4]+curgwCoefIn[1,3])*0.0283168	#m3 d-1#
gwOut0=(curRecharge[,4]*curgwCoefOut[1,4]+curgwCoefOut[1,3])*0.0283168	#m3 d-1#
#
gwIn0[curRecharge[,4]<=curgwCoefIn[1,2]]=0#
gwOut0[curRecharge[,4]>=curgwCoefOut[1,2]]=0#
#
gwIn0[gwIn0<0]=0#
gwOut0[gwOut0<0]=0#
#
daily_gwIn0=approxfun(curFluxDOY,gwIn0,method="constant")#
daily_gwOut0=approxfun(curFluxDOY,gwOut0,method="constant")#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY
out<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,daily_gwIn0(out[,1])*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),daily_gwOut0(out[,1])*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
vignette("compiledCode")
i
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,ip=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")
system.time(out<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")#
)
system.time(out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
)
outSODA=out
system.time(outRK<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")#
)
plot(log10(outSODA[,2]),log10(outRK[,2]))
source("nhldWatershedModel_onlyHydro_dynRechargeSupporting.R")
