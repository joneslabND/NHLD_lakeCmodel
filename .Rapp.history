library(glmtools)
quit()
library(Rgtk2)
library(RGtk2)
remove.packages(RGtk2)
remove.packages('RGtk2')
library("RGtk2")
remove.packages('RGtk2')
(1.6-1)/1
(1.6543-1.0423)/1.0423
15*40*50
15*40*25
15*40*25*1.48
x=seq(1,200)
1/0.69
1/.13
15872*(55000/(9728+55000))
15872*(55000/(9728+55000))+55000
(10250+388)/68486.59
(10250+388)/68486.59*12
10250+388
10250+388*6
10638*6
10250+388
10638*2
15872*(55000/(55000+9728))
13486.59+55000
21276/68486.59
1864.39+357.76
p=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)
Vp
Ve
Ve*0.2
##### Simplest CH4 ecosystem model#
##### 11-5-14#
##### WEW & SEJ#
#
rm(list=ls())#
#
library(deSolve)#
#
# set up ordinary differential equations (ODEs) in function for deSolve to use for each time step#
#
# State variables:#
#		1. CH4 in profundal sediment#
#		2. CH4 in littoral sediment#
#		3. CH4 in epilimnion#
#
# Daily time step#
#
timeStepCH4<-function(times,y,params){#
	with(as.list(params){#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	})#
}#
#
# Parameters#
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)#
#
init=c(0.2*Vp,0.2*Vl,0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
timeStepCH4<-function(times,y,params){#
	with(as.list(params){#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	)}#
}
timeStepCH4<-function(times,y,params){#
	with(as.list(params){#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	})#
}
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	})#
}
rm(list=ls())#
#
library(deSolve)#
#
# set up ordinary differential equations (ODEs) in function for deSolve to use for each time step#
#
# State variables:#
#		1. CH4 in profundal sediment#
#		2. CH4 in littoral sediment#
#		3. CH4 in epilimnion#
#
# Daily time step#
#
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
	})#
}
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)#
#
init=c(0.2*Vp,0.2*Vl,0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris
out=ode(y=init,times=t.s,func=timeSt,parms=params)
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris #
atmCH4=0.1	# [mol CH4 m-3]
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris --> Stuart will remember how to do this dynamically#
atmCH4=0.1	# [mol CH4 m-3]Will thinks this is about right --> We can check this and use whatever the global average is
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
dPdt=5
dLdt=2
dEdt=1
list(dPdt,dLdt,dEdt)
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
		return(list(dP.dt,dL.dt,dE.dt))#
	})#
}
# Parameters#
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)#
#
init=c(0.2*Vp,0.2*Vl,0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris --> Stuart will remember how to do this dynamically#
atmCH4=0.1	# [mol CH4 m-3]Will thinks this is about right --> We can check this and use whatever the global average is
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
init=c(0.2*Vp,0.2*Vl,0.2*Ve)
length(init)
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
		return(as.list(c(dP.dt,dL.dt,dE.dt)))#
	})#
}
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
timeStepCH4<-function(times,y,params){#
	with(as.list(params),{#
		P=y[1]	# CH4 in profundal sediment#
		L=y[2]	# CH4 in littoral sediment#
		E=y[3]	# CH4 in epilimnion#
		#dPdt=production-diffusion; assuming no ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(???)#
		dP.dt=Ap*(GPP*zmix*sed*yield-Pdiff*(P/Vp-E/Ve))#
		#dLdt=production-diffusion-ebullition#
		#		production=f(GPP,settling,yield)#
		#		diffusion=f(E,L,???)#
		#		ebullition=f(L,???)#
		dL.dt=Al*(GPP*zmix*sed*yield-Ldiff*(L/Vl-E/Ve))-ebull*L#
		#dEdt=production+diffusion (littoral and profundal)-atm. diffusion-oxidation#
		#		production=f(GPP)????#
		#		diffusion=f(E,L,P,???)#
		#		atm. diffusion=f(E,atm)#
		#		oxidation=f(E)#
		dE.dt=GPP*Eprod*Ve+Pdiff*(P/Vp-E/Ve)*Ap+Ldiff*(L/Vl-E/Ve)*Al-k*(E/Ve-atmCH4)*Ae-oxE*E#
		list(c(dP.dt,dL.dt,dE.dt))#
	})#
}
Ap=1250		# Area of profundal sediments; [m2]#
Al=250		# Area of littoral sediments; [m2]#
Ae=Ap+Al		# Surface area of lake; [m2]#
activeLayerDepth=0.2	# Active layer depth of sediments; [m]#
Vp=Ap*activeLayerDepth		# Volume of "active" profundal sediments; [m3]#
Vl=Al*activeLayerDepth		# Volume of "active" littoral sediments; [m3]#
zmix=2	# Mixed layer depth of lake; [m]#
Ve=Ae*zmix		# Volume of epilimnion; [m3]#
sed=0.3		# Proportion of areal GPP that settles to sediments; []#
yield=0.25	# Molar yield of CH4 from algal C; [mol CH4 (mol algal C)-1]#
Pdiff=0.001	# Mass transfer coefficient/diffusivity???; [m d-1]#
Ldiff=0.005	# Mass transfer coefficient/diffusivity???; [m d-1]#
ebull=0.1		# Fraction of production released as ebullition [d-1] -> could be a more complex function that causes ebullition at a critical saturating concentration; could also be probabalistic#
Eprod=0.0001	# Epilimnetic CH4 production per unit GPP; [mol CH4 (mol C)-1]#
k=0.4	# Piston velocity; [m d-1]#
oxE=0.9	# Fraction of epilimnion CH4 lost to oxidation; [d-1]#
params=c(Vp=Vp,Vl=Vl,Ve=Ve,Ap=Ap,Al=Al,Ae=Ae,zmix=zmix,sed=sed,yield=yield,Pdiff=Pdiff,Ldiff=Ldiff,ebull=ebull,Eprod=Eprod,k,oxE)
init=c(0.2*Vp,0.2*Vl,0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris --> Stuart will remember how to do this dynamically#
atmCH4=0.1	# [mol CH4 m-3]Will thinks this is about right --> We can check this and use whatever the global average is#
#
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
dim(out)
head(out)
init=c(P=0.2*Vp,L=0.2*Vl,E=0.2*Ve)		#starting all the same (sort of like after mixis); 200 uM#
t.s=1:180#
#
GPP=0.1		# [mol C m-3 d-1]Jake says this is average for morris --> Stuart will remember how to do this dynamically#
atmCH4=0.1	# [mol CH4 m-3]Will thinks this is about right --> We can check this and use whatever the global average is#
#
out=ode(y=init,times=t.s,func=timeStepCH4,parms=params)
head(out)
dev.new()#
par(mfrow=c(3,1))#
plot(out[,1],out[,2],type='l',lwd=2,xlab="Time",ylab="Profundal CH4")#
plot(out[,1],out[,3],type='l',lwd=2,xlab="Time",ylab="Littoral CH4",col='red')#
plot(out[,1],out[,4],type='l',lwd=2,xlab="Time",ylab="Epilimnion CH4",col='green')
dim(out)
out[180,]
65.366/Ve
65.366/Ve*1000
DecayVector <- c(0.05,0.12,0.14,0.05,0.06,0.09,0.05,0.14,0.15)#
TempVector <- c(5,20,35,5,20,35,5,20,35)#
UVBVector <- c(2,25,50,25,2,2,50,50,25)#
StricklerFig4pH10 <- data.frame(Decay=DecayVector, Temp=TempVector, UVB=UVBVector)#
#
# Fit the model (including all interactions) using lm#
model=lm(Decay~Temp*UVB,StricklerFig4pH10)#
summary(model) #
par(mfrow=c(2,2)) #
plot(model)
DecayVector <- c(0.05,0.12,0.14,0.05,0.06,0.09,0.05,0.14,0.15)#
TempVector <- c(5,20,35,5,20,35,5,20,35)#
UVBVector <- c(2,25,50,25,2,2,50,50,25)#
StricklerFig4pH10 <- data.frame(Decay=DecayVector, Temp=TempVector, UVB=UVBVector)#
#
# Fit the model (including all interactions) using lm#
model=lm(Decay~Temp+UVB,StricklerFig4pH10)#
summary(model) #
par(mfrow=c(2,2)) #
plot(model)
DecayVector <- c(0.05,0.12,0.14,0.05,0.06,0.09,0.05,0.14,0.15)#
TempVector <- c(5,20,35,5,20,35,5,20,35)#
UVBVector <- c(2,25,50,25,2,2,50,50,25)#
StricklerFig4pH10 <- data.frame(Decay=DecayVector, Temp=TempVector, UVB=UVBVector)#
#
# Fit the model (including all interactions) using lm#
model=lm(Decay~Temp,StricklerFig4pH10)#
summary(model) #
par(mfrow=c(2,2)) #
plot(model)
exp(2)
x=5
y=2
z=matrix(NA,10,10)
ls9)
ls()
str(ls())
str(x)
str(y)
str(z)
students=c(#
"Amanda",#
"Maggie",#
"Martha",#
"Margaret",#
"Meredith",#
"Brandon",#
"Julia",#
"Pete",#
"Lainey",#
"Michael",#
"Toby"#
)
length(students)
sample(students,length(students),replace=FALSE)
file.choose()
choose.file()
?sum
?c
v=c(1,2,3,20)
v
v=1:4
v
rm(list=ls())
1:4
v
v=1:4
v
v=seq(from=2,to=24,by=2)
v
?seq
b=seq(to=4)
b
b=seq(from=4)
b
rep(2,5)
v
length(v)
max(v)
min(v)
range(v)
rangeofv=range(v)
length(rangeofv)
length(range(v))
v
v>6
A=matrix(0,nrow=2,ncol=2)
A
A=matrix(1:4,nrow=2,ncol=2)
A
dim(A)
nrow(A)
length(A)
t(A)
a=list(name="walleye",length=225,tagged=TRUE)
a
a$name
a$length
names=c("walleye","perch")
weight=c(270,57)
d=data.frame(names=names,weight=weigth,stringsAsFactors=FALSE)
d=data.frame(names=names,weight=weight,stringsAsFactors=FALSE)
d
d[1,1]
d[,1]
d$names
students=c(#
"Amanda",#
"Maggie",#
"Martha",#
"Meg",#
"Meredith",#
"Brandon",#
"Julia",#
"Peter",#
"Lainey",#
"Mike",#
"Toby"#
)#
#
sample(students,length(students),replace=FALSE)
t=1:180#
#
a=0.5#
b=1#
c=-0.5
plot(t,a+b*exp(c),type='l')
plot(t,a+b*exp(c*t),type='l')
?glm
?guassian
?gaussian
?glm
?gaussian
88633*1.609
87975/91089.32
87975*1.035
(91089.32-87975)/87975
250*12
87975*0.035
91000*1.03
91000*1.03^3
91000*1.03^4
require("deSolve")
persistCannibalism<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=Ba*(C*Va)/(C+Ka)*Ea-Ba*da		#g (L*day)^-1#
		dCdt=Ba*da*m-Ba*(C*Va)/(C+Ka)		#g (L*day)^-1#
		res=c(dBadt,dCdt)#
		list(res)#
	})#
}
parms = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, m=0.5)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02, C = 0)#
#
outPC=ode(y=init,times=times,func=persistCannibalism,parms=parms)#
#
dev.new()#
par(mfrow=c(2,1))#
plot(outPC[,1],log10(outPC[,2]/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPC[,1],outPC[,3],type='l',xlab='time',ylab='carbon (g)')
persist<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=-Ba*da		#g (L*day)^-1#
		res(c(dBadt))#
		list(res)#
	})#
}
parms = c(da = 0.1)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02)
persist<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=-Ba*da		#g (L*day)^-1#
		res(c(dBadt))#
		list(res)#
	})#
}#
#
#parameters#
# da= mortality rate [day^-1]#
#
# assumptions#
# 20e-15 g (femtograms of C per cell)#
# start with 1e12 cells per L (0.02 g C in Ba)#
#
parms = c(da = 0.1)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02)#
#
outP=ode(y=init,times=times,func=persist,parms=parms)
persist<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=-Ba*da		#g (L*day)^-1#
		res=c(dBadt)#
		list(res)#
	})#
}
parms = c(da = 0.1)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02)#
#
outP=ode(y=init,times=times,func=persist,parms=parms)
dev.new()#
plot(outP[,1],log10(outP[,2]/(20e-15)),xlab="time",ylab="log10 cells",type='l')
# population decay without evolution, but C recycling#
persistCannibalism<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=Ba*(C*Va)/(C+Ka)*Ea-Ba*da		#g (L*day)^-1#
		dCdt=Ba*da*m-Ba*(C*Va)/(C+Ka)		#g (L*day)^-1#
		res=c(dBadt,dCdt)#
		list(res)#
	})#
}#
#
# parameters#
# Va= mass-specific maximum uptake rate [g (g*day)^-1]#
# Ka= carbon half-saturation constant [g L^-1]#
# Ea= growth efficiency#
# da= mortality rate [day^-1]#
# m= fraction of dead bacteria available for consumption#
#
# assumptions#
# 20e-15 g (femtograms of C per cell)#
# start with 1e12 cells per L (0.02 g C in Ba)#
#
# Apsergillus niger??? Ka=15 uM glucose, Va=1 umol (gram dry weight)^-1 second^-1 Jorgensen et al. 2007 Microbiology, 153: 1963-1973#
					#  Ka=0.0011 g C L^-1; Va=12.4 g C (g bacterial C)^-1 day^-1#
#
#parms = c(Va = 10^-10, Ka = 10^-10, Ea = 0.75, da = 0.1, m=0.5) # these are from Jay's old script#
parms = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, m=0.5)#
times = seq(0,1000,0.1)#
init = c(Ba = 0.02, C = 0)#
#
outPC=ode(y=init,times=times,func=persistCannibalism,parms=parms)#
#
dev.new()#
par(mfrow=c(2,1))#
plot(outPC[,1],log10(outPC[,2]/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPC[,1],outPC[,3],type='l',xlab='time',ylab='carbon (g)')
persistCannibalismMut<-function(t,x,parms){#
	with(as.list(c(parms,x)),{#
		dBadt=Ba*(C*Va)/(C+Ka)*Ea-Ba*da#
		dBmdt=Bm*(C*Vm)/(C+Km)*Em-Bm*dm#
		dCdt=Ba*da*m-Ba*(C*Va)/(C+Ka)+Bm*dm*m-Bm*(C*Vm)/(C+Km)#
		res=c(dBadt,dBmdt,dCdt)#
		list(res)#
	})#
}#
# simulate with lower death rate in mutant#
#
# fraction of initial population that are mutant#
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=12, Km=0.0011, Em=0.75, dm=0.05, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics
dev.new()#
par(mfrow=c(2,2))#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 cells",type='l')
par(mfrow=c(2,3))#
plot(outPCmut[,1],rowSums(outPCmut[,2:3]),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)',type="l")
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)',type="l")
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 0, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=0, Km=0.0011, Em=0.75, dm=0.05, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=12, Km=0.0011, Em=0.75, dm=0.05, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=12, Km=0.0011, Em=0.8, dm=0.1, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.75, da = 0.1, Vm=12, Km=0.0011, Em=0.9, dm=0.1, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.5, da = 0.1, Vm=12, Km=0.0011, Em=0.9, dm=0.1, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
fracMut=1e-5#
#
parmsMut = c(Va = 12, Ka = 0.0011, Ea = 0.5, da = 0.1, Vm=12, Km=0.0011, Em=0.9, dm=0.05, m=0.5)#
initMut = c(Ba = 0.02-0.02*fracMut, Bm=0.02*fracMut, C = 0)#
#
outPCmut=ode(y=initMut,times=times,func=persistCannibalismMut,parms=parmsMut)#
#
# summary plots of model with mutant dynamics#
dev.new()#
par(mfrow=c(2,3))#
plot(outPCmut[,1],log10(rowSums(outPCmut[,2:3])/(20e-15)),xlab="time",ylab="log10 cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,2]/(20e-15)),xlab="time",ylab="log10 ancestral cells",type='l')#
plot(outPCmut[,1],log10(outPCmut[,3]/(20e-15)),xlab="time",ylab="log10 mutant cells",type='l')#
plot(outPCmut[,1],outPCmut[,3]/rowSums(outPCmut[,2:3]),xlab="time",ylab="prop. cells",type='l')#
plot(outPCmut[,1],outPCmut[,4],type='l',xlab='time',ylab='carbon (g)')
rm(list=ls())#
#
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/NHLD_lakeCmodel")#
#
########## load utility functions and packages#
source("nhldWatershedModelSupporting.R")#
require(deSolve)#
require(LakeMetabolizer)#
#
######## load forcing and flux data#
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/VICforcings&output/PROC")#
#
cells=gsub("FLUX_","",grep("FLUX",list.files(),value=TRUE))#
#
forceFiles=grep("FORCE",list.files(),value=TRUE)#
fluxFiles=grep("FLUX",list.files(),value=TRUE)#
#
#### UNDERC includes four VIC cells#
# 46.28125_-89.53125#
# 46.28125_-89.46875#
# 46.21875_-89.53125#
# 46.21875_-89.46875#
UNDERCcells=cells[c(169,170,182,183)]#
#
# Lat Long Year Month Day Runoff_mmDay Precip_mmDay EvapOpenWater_mmDay#
flux=read.table(paste("FLUX_",UNDERCcells[1],sep=""),header=FALSE)#
# Lat Long Year Month Day Hour NetLW_Wm2 NetSW_Wm2 LW_Wm2 SW_Wm2 AirTemp_dC atmPress_kPa windspeed_mS@10m relHumid_fraction#
force=read.table(paste("FORCE_",UNDERCcells[1],sep=""),header=FALSE)#
#
# starting year/month/day, ending year/mnth/day, & set up force/flux#
startYear=2005#
startMonth=5#
startDay=1#
#
endYear=2013#
endMonth=9#
endDay=30#
#
curForce=force[which(((force[,3]==startYear) & (force[,4]==startMonth) & (force[,5]==startDay) & (force[,6]==0))):which(((force[,3]==endYear) & (force[,4]==endMonth) & (force[,5]==endDay) & (force[,6]==23))),]#
#
curFlux=flux[which(((flux[,3]==startYear) & (flux[,4]==startMonth) & (flux[,5]==startDay))):which(((flux[,3]==endYear) & (flux[,4]==endMonth) & (flux[,5]==endDay))),]#
#
curFluxDOY=1:nrow(curFlux)#
curForceDOY=rep(curFluxDOY,each=24)#
#
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/NHLD_lakeCmodel")#
#
###### forcing functions#
dailyPrecip=approxfun(curFluxDOY,curFlux[,7],method="constant")#
dailyEvap=approxfun(curFluxDOY,curFlux[,8],method="constant")#
dailyRunoff=approxfun(curFluxDOY,curFlux[,6],method="constant")#
dailyWind=approxfun(curFluxDOY,tapply(curForce[,13],curForceDOY,FUN=mean),method="constant")#
#dailySun<-function(day){#
#	todayHourlySun=sw.to.par.base(curForce[curForceDOY==day,10])		# umol m2 sec; SW to PAR based on Read...#
#	return(todayHourlySun)#
#}#
#dailyMaxWind<-function(day){#
#	todayMaxWind=max(curForce[curForceDOY==day,13])*(1/10)^0.15		# convert 10m wind to 1m for preston model tPOC deposition#
#	return(todayMaxWind)#
#}#
#
####### ice cover: using regressions from Finland ()#
# -> alternative: try looking at NTL data...; fit model with degree days?#
#
###***** this stuff will have troubles if ice on happens after january 1 ******####
aprilForce=force[force[,4]==4,]#
novForce=force[force[,4]==11,]#
#
aprilAT=tapply(aprilForce[,11],aprilForce[,3],FUN=mean)#
novAT=tapply(novForce[,11],novForce[3],FUN=mean)#
#
iceOnDOY=(novAT+28.8)/0.19+182	#equation for November from inland North -> has latest ice on; pick this one because study area much higher N#
#
iceOffDOY=(aprilAT-49.7)/-0.16+182-365	#Coastal/South model for breakup; again earliest date, but want this bias...#
#
iceON=numeric(nrow(curFlux))#
years=sort(unique(curFlux[,3]))#
for(j in 1:length(years)){#
	curYear=curFlux[curFlux[,3]==years[j],]#
	curDOY=as.numeric(strftime(strptime(paste(curYear[,3],curYear[,4],curYear[,5],sep="-"),format="%Y-%m-%d"),format="%j"))#
	iceON[curFlux[,3]==years[j]]=((curDOY<iceOffDOY[names(iceOffDOY)==years[j]]) | (curDOY>iceOnDOY[names(iceOnDOY)==years[j]]))*1#
}#
#
####### load lake/watershed information#
UNDERCsheds=read.table("../NHLDwatershedDelineations/UNDERCsheds_5-13-15.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
#
GFLOWoutput=read.table("../gflowOutput/gflowSensitivity_5-21-15/NHLD_GFLOW_UNDERC_20150520_Simplify010_RegK1_LocK0pt01_OutputLong.txt",header=TRUE,stringsAsFactors=FALSE)#
colnames(GFLOWoutput)[1]="Permanent_"
i=4
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[UNDERCsheds$Permanent_==curLakeID]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
#
# try volume model from del Giorgio group now that we have difference in elevation data#
#
Perim0=UNDERCsheds$Perimeter[UNDERCsheds$Permanent_==curLakeID]			#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.5#
zmax1=zmax0*2.5#1.5#
uScale=(zmax1-zmax0)/zmax1#
A1=A0/(1-(p*uScale^2+(1-p)*uScale))#
V1=V0/(1-((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p)))#
curShedArea=UNDERCsheds$Area_m2[UNDERCsheds$Permanent_==curLakeID]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=(V1-V0))$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
stage0=zmax1-u0*zmax1#
alpha=0.99#
stageOut=alpha*stage0#
#
# calculate concentrations of DIC, DOC, TP based on landcover#
#setwd("/Files/NDongoing/ScalingLakeProcessesVilasCty/vilasWatersheds_post5-17-14/waterConstituents")#
ntlGW=read.csv("NTLlter__groundwater_chemistry.csv",header=TRUE,fill=TRUE)#
ntlGW=ntlGW[,c(1:4,9:10,14)]#
ntlGW=ntlGW[!is.na(ntlGW[,5]),]#
ntlGW=ntlGW[ntlGW$doc<10,]#
lottig2011DOC=read.table("lottig2012Fig.txt",header=FALSE,sep=",")#
kH=29.41	# Henry's Law constant for CO2 in water [L atm mol-1]	# temperature sensitivity#
streamDOC=exp(1.3961+3.245*(UNDERCsheds$percentWetland[i]/100))/12*1000/1000	# from lottig 2012; mol m-3#
streamPOC=3/12*1000/1000		# ~3 mg L-1; buffam 2011; mol m-3#
streamDIC=10/12*1000/1000		#10 mg L-1; lottig 2011; mol m-3#
streamP=0.04/31*1000/1000		#.025 mg L-1 TDP & 0.04 mg L-1 TP; lottig 2011; mol m-3#
gwDOC=13/12*1000/1000#median(ntlGW$doc,na.rm=TRUE)/12*1000/1000	# mol m-3#
gwDIC=median(ntlGW$dic,na.rm=TRUE)/12*1000/1000	# mol m-3#
gwP=median(ntlGW$totp,na.rm=TRUE)/31*1000/1e6		# mol m-3#
precipDOC=1.1/12*1000/1000		#mol m-3; from Likens et al. 1983 @ Hubbard Brook#
precipDIC=400/1e6*1/kH*1000	# mol C m-3; assumed in equilibrium with atmosphere#
precipP=0.01/31*1000/1000	# mol m-3; Murphy & DOskey 1976 JGLR#
#DR=((curLakeArea*10^-6)^0.5)/curMeanDepth	# dynamic ratio; unitless; from Hakanson & Bryhn 2008. Water Air Soil Pollution, 187: 119-147. impacts turbulence and sedimentation#
#distShore=sqrt(curLakeArea/pi)/2		#mean distance from shore; m; from GIS#
#if(DR<0.26){		#adjustment to sedimentation rate based on turbulence, [unitless]; Hakanson & Bryhn 2008. Water Air Soil Pollution, 187: 119-147#
#
#	Ydr=DR/0.26#
#}else{#
#	Ydr=0.26/DR#
#} 	#
# need a hypovolume initially to start simulation#
#hypoVolume=0#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL,precipDIC=precipDIC,precipDOC=precipDOC,streamDIC=streamDIC,streamDOC=streamDOC,gwDIC=gwDIC,gwDOC=gwDOC,kH=kH)#
#
initialX=c(V=V0,DIC=0.3/12*V0,DOC=8/12*V0,tPOC=0.8/12*V0,phyto=0.02/12*V0,P=0.5/1000/31*V0)#
#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")#
#out=out[-(1:5),]		# always drops a lot over first few days#
#out=out[-nrow(out),]		# last time step always NA#
#
outHydro=cbind(out[,1:2],NA,NA,NA,NA,NA)#
for(j in 1:nrow(outHydro)){#
	if(!is.na(outHydro[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=(V1-outHydro[j,2]))$root,4)#
		outHydro[j,3]=A1*(1-(p*uj^2+(1-p)*uj))#
		outHydro[j,4]=zmax1-zmax1*uj#
		outHydro[j,5]=2*pi*sqrt(outHydro[j,3]/pi)*DL#
		outHydro[j,6]=10^(-0.518*log10(out[j,4]/out[j,2]*12)+1.006)#
		if(outHydro[j,6]>zmax1){outHydro[j,6]=zmax1}#
		umix=outHydro[j,6]/outHydro[j,4]#
		Vu=(6*umix-3*(1-p)*umix^2-2*p*umix^3)/(3+p)#
		outHydro[j,7]=outHydro[j,2]*Vu#
	}#
}#
colnames(outHydro)[3:7]=c("A","stage","perim","zmix","Vepi")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=outHydro[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(outHydro[,1],dailyRunoff(outHydro[,1])*(curShedArea-outHydro[,3])/1000,dailyPrecip(outHydro[,1])*outHydro[,3]/1000,gwIn0*outHydro[,5]/Perim0,QoutSim,dailyEvap(outHydro[,1])*outHydro[,3]/1000*(1-iceON[1:nrow(outHydro)]),gwOut0*outHydro[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
startRow=out[1,1]#
endRow=out[nrow(out),1]#
plotDates=strptime(paste(curFlux[startRow:endRow,3],curFlux[startRow:endRow,4],curFlux[startRow:endRow,5],sep="-"),format="%Y-%m-%d")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(plotDates,hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(plotDates,outHydro[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(plotDates,outHydro[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))#
outConc=out#
outConc[,3]=outConc[,3]/outConc[,2]*12		#mg L-1#
outConc[,4]=outConc[,4]/outConc[,2]*12		#mg L-1#
outConc[,5]=outConc[,5]/outHydro[,7]*12		#mg L-1#
outConc[,6]=outConc[,6]/outHydro[,7]*12		#mg L-1#
outConc[,7]=outConc[,7]/outConc[,2]*31*1000		#ug L-1#
#
atmCO2=400 # [ppm]#
		atmEquilCO2=1*atmCO2/1e6/kH*1000	# concentration of CO2 in water at equilibrium with atmosphere, [mol C m-3]#
#
phyto_C2Chl=50#
phytoC2P=70#
#
dev.new()#
par(mfrow=c(3,3))#
plot(plotDates,out[,2],type='l',xlab='time',ylab='Volume (m3)')#
plot(plotDates,outConc[,3],type='l',xlab='time',ylab='DIC (mg C L-1)')#
abline(h=atmEquilCO2*12,col='red')#
plot(plotDates,outConc[,4],type='l',xlab='time',ylab='DOC (mg C L-1)')#
plot(plotDates,outConc[,5],type='l',xlab='time',ylab='tPOC (mg C L-1)')#
plot(plotDates,outConc[,6],type='l',xlab='time',ylab='phyto POC (mg C L-1)')#
plot(plotDates,outConc[,6]/phyto_C2Chl*1000,type='l',xlab='time',ylab='chl (ug C L-1)')#
plot(plotDates,outConc[,7],type='l',xlab='time',ylab='SRP (ug P L-1)')#
plot(plotDates,(outConc[,7]+outConc[,6]/12/phytoC2P*31*1000),type='l',xlab='time',ylab='TP (ug P L-1)')#
#
apply(outConc,2,range)
streamPOC=3/12*1000/1000		# ~3 mg L-1; buffam 2011; mol m-3#
streamDIC=10/12*1000/1000		#10 mg L-1; lottig 2011; mol m-3#
streamP=0.1/31*1000/1000#0.04/31*1000/1000		#.025 mg L-1 TDP & 0.04 mg L-1 TP; lottig 2011; mol m-3#
gwDOC=13/12*1000/1000#median(ntlGW$doc,na.rm=TRUE)/12*1000/1000	# mol m-3#
gwDIC=median(ntlGW$dic,na.rm=TRUE)/12*1000/1000	# mol m-3#
gwP=median(ntlGW$totp,na.rm=TRUE)/31*1000/1e6		# mol m-3#
precipDOC=1.1/12*1000/1000		#mol m-3; from Likens et al. 1983 @ Hubbard Brook#
precipDIC=400/1e6*1/kH*1000	# mol C m-3; assumed in equilibrium with atmosphere#
precipP=0.01/31*1000/1000	# mol m-3; Murphy & DOskey 1976 JGLR#
#DR=((curLakeArea*10^-6)^0.5)/curMeanDepth	# dynamic ratio; unitless; from Hakanson & Bryhn 2008. Water Air Soil Pollution, 187: 119-147. impacts turbulence and sedimentation#
#distShore=sqrt(curLakeArea/pi)/2		#mean distance from shore; m; from GIS#
#if(DR<0.26){		#adjustment to sedimentation rate based on turbulence, [unitless]; Hakanson & Bryhn 2008. Water Air Soil Pollution, 187: 119-147#
#
#	Ydr=DR/0.26#
#}else{#
#	Ydr=0.26/DR#
#} 	#
# need a hypovolume initially to start simulation#
#hypoVolume=0#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL,precipDIC=precipDIC,precipDOC=precipDOC,streamDIC=streamDIC,streamDOC=streamDOC,gwDIC=gwDIC,gwDOC=gwDOC,kH=kH)#
#
initialX=c(V=V0,DIC=0.3/12*V0,DOC=8/12*V0,tPOC=0.8/12*V0,phyto=0.02/12*V0,P=0.5/1000/31*V0)#
#
times=curFluxDOY
out<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")#
#out=out[-(1:5),]		# always drops a lot over first few days#
#out=out[-nrow(out),]		# last time step always NA#
#
outHydro=cbind(out[,1:2],NA,NA,NA,NA,NA)#
for(j in 1:nrow(outHydro)){#
	if(!is.na(outHydro[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=(V1-outHydro[j,2]))$root,4)#
		outHydro[j,3]=A1*(1-(p*uj^2+(1-p)*uj))#
		outHydro[j,4]=zmax1-zmax1*uj#
		outHydro[j,5]=2*pi*sqrt(outHydro[j,3]/pi)*DL#
		outHydro[j,6]=10^(-0.518*log10(out[j,4]/out[j,2]*12)+1.006)#
		if(outHydro[j,6]>zmax1){outHydro[j,6]=zmax1}#
		umix=outHydro[j,6]/outHydro[j,4]#
		Vu=(6*umix-3*(1-p)*umix^2-2*p*umix^3)/(3+p)#
		outHydro[j,7]=outHydro[j,2]*Vu#
	}#
}#
colnames(outHydro)[3:7]=c("A","stage","perim","zmix","Vepi")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=outHydro[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(outHydro[,1],dailyRunoff(outHydro[,1])*(curShedArea-outHydro[,3])/1000,dailyPrecip(outHydro[,1])*outHydro[,3]/1000,gwIn0*outHydro[,5]/Perim0,QoutSim,dailyEvap(outHydro[,1])*outHydro[,3]/1000*(1-iceON[1:nrow(outHydro)]),gwOut0*outHydro[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
startRow=out[1,1]#
endRow=out[nrow(out),1]#
plotDates=strptime(paste(curFlux[startRow:endRow,3],curFlux[startRow:endRow,4],curFlux[startRow:endRow,5],sep="-"),format="%Y-%m-%d")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(plotDates,hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(plotDates,outHydro[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(plotDates,outHydro[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))#
outConc=out#
outConc[,3]=outConc[,3]/outConc[,2]*12		#mg L-1#
outConc[,4]=outConc[,4]/outConc[,2]*12		#mg L-1#
outConc[,5]=outConc[,5]/outHydro[,7]*12		#mg L-1#
outConc[,6]=outConc[,6]/outHydro[,7]*12		#mg L-1#
outConc[,7]=outConc[,7]/outConc[,2]*31*1000		#ug L-1#
#
atmCO2=400 # [ppm]#
		atmEquilCO2=1*atmCO2/1e6/kH*1000	# concentration of CO2 in water at equilibrium with atmosphere, [mol C m-3]#
#
phyto_C2Chl=50#
phytoC2P=70#
#
dev.new()#
par(mfrow=c(3,3))#
plot(plotDates,out[,2],type='l',xlab='time',ylab='Volume (m3)')#
plot(plotDates,outConc[,3],type='l',xlab='time',ylab='DIC (mg C L-1)')#
abline(h=atmEquilCO2*12,col='red')#
plot(plotDates,outConc[,4],type='l',xlab='time',ylab='DOC (mg C L-1)')#
plot(plotDates,outConc[,5],type='l',xlab='time',ylab='tPOC (mg C L-1)')#
plot(plotDates,outConc[,6],type='l',xlab='time',ylab='phyto POC (mg C L-1)')#
plot(plotDates,outConc[,6]/phyto_C2Chl*1000,type='l',xlab='time',ylab='chl (ug C L-1)')#
plot(plotDates,outConc[,7],type='l',xlab='time',ylab='SRP (ug P L-1)')#
plot(plotDates,(outConc[,7]+outConc[,6]/12/phytoC2P*31*1000),type='l',xlab='time',ylab='TP (ug P L-1)')#
#
apply(outConc,2,range)
40/1000/31
0.1/31*1000/1000
curShedArea
A0
curShedArea-A0
(curShedArea-A0)*dailyRunoff(1)
(curShedArea-A0)*dailyRunoff(2)
(curShedArea-A0)*dailyRunoff(3)
(curShedArea-A0)*dailyRunoff(4)
(curShedArea-A0)*dailyRunoff(5)
(curShedArea-A0)*dailyRunoff(6)
(curShedArea-A0)*dailyRunoff(7)
(curShedArea-A0)*dailyRunoff(8)
(curShedArea-A0)*dailyRunoff(9)
(curShedArea-A0)*dailyRunoff(10)
0.04/31
i=17
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[UNDERCsheds$Permanent_==curLakeID]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
#
# try volume model from del Giorgio group now that we have difference in elevation data#
#
Perim0=UNDERCsheds$Perimeter[UNDERCsheds$Permanent_==curLakeID]			#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.5#
zmax1=zmax0*2.5#1.5#
uScale=(zmax1-zmax0)/zmax1#
A1=A0/(1-(p*uScale^2+(1-p)*uScale))#
V1=V0/(1-((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p)))#
curShedArea=UNDERCsheds$Area_m2[UNDERCsheds$Permanent_==curLakeID]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=(V1-V0))$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
stage0=zmax1-u0*zmax1#
alpha=0.99#
stageOut=alpha*stage0#
#
# calculate concentrations of DIC, DOC, TP based on landcover#
#setwd("/Files/NDongoing/ScalingLakeProcessesVilasCty/vilasWatersheds_post5-17-14/waterConstituents")#
ntlGW=read.csv("NTLlter__groundwater_chemistry.csv",header=TRUE,fill=TRUE)#
ntlGW=ntlGW[,c(1:4,9:10,14)]#
ntlGW=ntlGW[!is.na(ntlGW[,5]),]#
ntlGW=ntlGW[ntlGW$doc<10,]#
lottig2011DOC=read.table("lottig2012Fig.txt",header=FALSE,sep=",")#
kH=29.41	# Henry's Law constant for CO2 in water [L atm mol-1]	# temperature sensitivity#
streamDOC=exp(1.3961+3.245*(UNDERCsheds$percentWetland[i]/100))/12*1000/1000	# from lottig 2012; mol m-3#
streamPOC=3/12*1000/1000		# ~3 mg L-1; buffam 2011; mol m-3#
streamDIC=10/12*1000/1000		#10 mg L-1; lottig 2011; mol m-3#
streamP=0.1/31*1000/1000#0.04/31*1000/1000		#.025 mg L-1 TDP & 0.04 mg L-1 TP; lottig 2011; mol m-3#
gwDOC=13/12*1000/1000#median(ntlGW$doc,na.rm=TRUE)/12*1000/1000	# mol m-3#
gwDIC=median(ntlGW$dic,na.rm=TRUE)/12*1000/1000	# mol m-3#
gwP=median(ntlGW$totp,na.rm=TRUE)/31*1000/1e6		# mol m-3#
precipDOC=1.1/12*1000/1000		#mol m-3; from Likens et al. 1983 @ Hubbard Brook#
precipDIC=400/1e6*1/kH*1000	# mol C m-3; assumed in equilibrium with atmosphere#
precipP=0.01/31*1000/1000	# mol m-3; Murphy & DOskey 1976 JGLR#
#DR=((curLakeArea*10^-6)^0.5)/curMeanDepth	# dynamic ratio; unitless; from Hakanson & Bryhn 2008. Water Air Soil Pollution, 187: 119-147. impacts turbulence and sedimentation#
#distShore=sqrt(curLakeArea/pi)/2		#mean distance from shore; m; from GIS#
#if(DR<0.26){		#adjustment to sedimentation rate based on turbulence, [unitless]; Hakanson & Bryhn 2008. Water Air Soil Pollution, 187: 119-147#
#
#	Ydr=DR/0.26#
#}else{#
#	Ydr=0.26/DR#
#} 	#
# need a hypovolume initially to start simulation#
#hypoVolume=0#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL,precipDIC=precipDIC,precipDOC=precipDOC,streamDIC=streamDIC,streamDOC=streamDOC,gwDIC=gwDIC,gwDOC=gwDOC,kH=kH)#
#
initialX=c(V=V0,DIC=0.3/12*V0,DOC=8/12*V0,tPOC=0.8/12*V0,phyto=0.02/12*V0,P=0.5/1000/31*V0)#
#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params,method="rk4")#
#out=out[-(1:5),]		# always drops a lot over first few days#
#out=out[-nrow(out),]		# last time step always NA#
#
outHydro=cbind(out[,1:2],NA,NA,NA,NA,NA)#
for(j in 1:nrow(outHydro)){#
	if(!is.na(outHydro[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=(V1-outHydro[j,2]))$root,4)#
		outHydro[j,3]=A1*(1-(p*uj^2+(1-p)*uj))#
		outHydro[j,4]=zmax1-zmax1*uj#
		outHydro[j,5]=2*pi*sqrt(outHydro[j,3]/pi)*DL#
		outHydro[j,6]=10^(-0.518*log10(out[j,4]/out[j,2]*12)+1.006)#
		if(outHydro[j,6]>zmax1){outHydro[j,6]=zmax1}#
		umix=outHydro[j,6]/outHydro[j,4]#
		Vu=(6*umix-3*(1-p)*umix^2-2*p*umix^3)/(3+p)#
		outHydro[j,7]=outHydro[j,2]*Vu#
	}#
}#
colnames(outHydro)[3:7]=c("A","stage","perim","zmix","Vepi")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=outHydro[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(outHydro[,1],dailyRunoff(outHydro[,1])*(curShedArea-outHydro[,3])/1000,dailyPrecip(outHydro[,1])*outHydro[,3]/1000,gwIn0*outHydro[,5]/Perim0,QoutSim,dailyEvap(outHydro[,1])*outHydro[,3]/1000*(1-iceON[1:nrow(outHydro)]),gwOut0*outHydro[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
startRow=out[1,1]#
endRow=out[nrow(out),1]#
plotDates=strptime(paste(curFlux[startRow:endRow,3],curFlux[startRow:endRow,4],curFlux[startRow:endRow,5],sep="-"),format="%Y-%m-%d")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(plotDates,hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(plotDates,hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(plotDates,outHydro[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(plotDates,outHydro[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))#
outConc=out#
outConc[,3]=outConc[,3]/outConc[,2]*12		#mg L-1#
outConc[,4]=outConc[,4]/outConc[,2]*12		#mg L-1#
outConc[,5]=outConc[,5]/outHydro[,7]*12		#mg L-1#
outConc[,6]=outConc[,6]/outHydro[,7]*12		#mg L-1#
outConc[,7]=outConc[,7]/outConc[,2]*31*1000		#ug L-1#
#
atmCO2=400 # [ppm]#
		atmEquilCO2=1*atmCO2/1e6/kH*1000	# concentration of CO2 in water at equilibrium with atmosphere, [mol C m-3]#
#
phyto_C2Chl=50#
phytoC2P=70#
#
dev.new()#
par(mfrow=c(3,3))#
plot(plotDates,out[,2],type='l',xlab='time',ylab='Volume (m3)')#
plot(plotDates,outConc[,3],type='l',xlab='time',ylab='DIC (mg C L-1)')#
abline(h=atmEquilCO2*12,col='red')#
plot(plotDates,outConc[,4],type='l',xlab='time',ylab='DOC (mg C L-1)')#
plot(plotDates,outConc[,5],type='l',xlab='time',ylab='tPOC (mg C L-1)')#
plot(plotDates,outConc[,6],type='l',xlab='time',ylab='phyto POC (mg C L-1)')#
plot(plotDates,outConc[,6]/phyto_C2Chl*1000,type='l',xlab='time',ylab='chl (ug C L-1)')#
plot(plotDates,outConc[,7],type='l',xlab='time',ylab='SRP (ug P L-1)')#
plot(plotDates,(outConc[,7]+outConc[,6]/12/phytoC2P*31*1000),type='l',xlab='time',ylab='TP (ug P L-1)')#
#
apply(outConc,2,range)
