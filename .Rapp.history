i=18
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))));print(UNDERCsheds$GNIS_Name[i])
i=19
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))));print(UNDERCsheds$GNIS_Name[i])
i=20
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))));print(UNDERCsheds$GNIS_Name[i])
i=21
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
i
UNDERCsheds[i,]
i=22
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))));print(UNDERCsheds$GNIS_Name[i])
i=23
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))));print(UNDERCsheds$GNIS_Name[i])
i=24
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))));print(UNDERCsheds$GNIS_Name[i])
UNDERCsheds
i=25
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))));print(UNDERCsheds$GNIS_Name[i])
gwOut0
gwIn0
i=26
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))));print(UNDERCsheds$GNIS_Name[i])
i=27
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
UNDERCsheds[i,]
A0
V0
V0/A0
Zmax
Zmax0
zmax0
dim(out)
out
UNDERCsheds
store=matrix(NA,27,4)#
for(i in 1:27){#
	curLakeID=UNDERCsheds$Permanent_[i]#
#
	store[i,1:2]=UNDERCsheds[i,c(1,3)]#
#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
store[i,3]=gwIn0#
store[i,4]=gwOut0#
}#
#
colnames(store)=c('Permanent_','Name','GWin_m3d','GWout_m3d')
i
gwIn0
gwOut0
store=matrix(NA,27,4)
i=1
curLakeID=UNDERCsheds$Permanent_[i]#
#
	store[i,1:2]=UNDERCsheds[i,c(1,3)]
store
store=matrix(NA,27,4)
curLakeID=UNDERCsheds$Permanent_[i]#
#
	store[i,1]=UNDERCsheds[i,1]#
	store[i,2]=UNDERCsheds[i,3]
store
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
store[i,3]=gwIn0#
store[i,4]=gwOut0
store
store=matrix(NA,27,4)#
for(i in 1:27){#
	curLakeID=UNDERCsheds$Permanent_[i]#
#
	store[i,1]=UNDERCsheds[i,1]#
	store[i,2]=UNDERCsheds[i,3]#
#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
store[i,3]=gwIn0#
store[i,4]=gwOut0#
}#
#
colnames(store)=c('Permanent_','Name','GWin_m3d','GWout_m3d')
store
i=26
curLakeID=UNDERCsheds$Permanent_[i]
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]
curGFLOW
store=store[-26,]
store
store=matrix(NA,27,4)#
for(i in 1:27){#
	curLakeID=UNDERCsheds$Permanent_[i]#
#
	store[i,1]=UNDERCsheds[i,1]#
	store[i,2]=UNDERCsheds[i,3]#
#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
store[i,3]=round(gwIn0,1)#
store[i,4]=round(gwOut0,1#
}#
#
colnames(store)=c('Permanent_','Name','GWin_m3d','GWout_m3d')#
#
store=store[-26,]
store=matrix(NA,27,4)#
for(i in 1:27){#
	curLakeID=UNDERCsheds$Permanent_[i]#
#
	store[i,1]=UNDERCsheds[i,1]#
	store[i,2]=UNDERCsheds[i,3]#
#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
store[i,3]=round(gwIn0,1)#
store[i,4]=round(gwOut0,1)#
}#
#
colnames(store)=c('Permanent_','Name','GWin_m3d','GWout_m3d')#
#
store=store[-26,]
store
write.table(store,"GFLOWpredictions_5-12-15.txt",row.names=FALSE,sep="\t")
t=1:100#
#
A=5#
mu=0.5#
lambda=0.1
t=1:100#
#
A=5#
mu=0.5#
lambda=0.1#
#
yt=A/(1+exp(4*mu/A*(lambda-t)+2))#
#
plot(t,yt,type='l')
store
GWin=as.numeric(store[,3])
GWout=as.numeric(store[,4])
df=data.frame(permanent=store[,1],name=store[,2],in=as.numeric(store[,3]),out=as.numeric(store[,4]),stringsAsFactors=FALSE)
df=data.frame(permanent=store[,1],name=store[,2],GWin=as.numeric(store[,3]),GWout=as.numeric(store[,4]),stringsAsFactors=FALSE)
df
df[order(df$GWin),]
df[order(df$GWout),]
head(UNDERCsheds)
UNDERCsheds[order(UNDERCsheds$WALA),]
UNDERCsheds
i=27
DL=UNDERCsheds$Perimeter/(2*sqrt(pi*UNDERCsheds$NHLD_lakes))
DLl=cbind(UNDERCsheds$GNIS_Name,DL)
DLl[order(DL),]
i=27
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
dim(out)
out
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
zmax
zmax1
dev.new()#
par(mfrow=c(3,3))
length(times)
plot(times,hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)
curShedArea
A0
dailyRunoff(98)
dailyRunoff(98)*(2276980-A0)/1000
V0
plot(1:300,dailyRunoff(1:300)*(2276980-A0)/1000,type='l')
plot(1:300,dailyRunoff(1:300)*(2276980-A0)/1000,type='l')
abline(h=V0,col='red')
UNDERCsheds
i=3
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
dim(out)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))
V0
dailyRunoff(1066)
dim(out)
dailyRunoff(1067)
length(time)
length(times)
dailyEvap(1060:1070)
dailyPrecip(1060:1070)
dailyRunoff(1060:1070)
plot(dailyRunoff(1:2192))
plot(dailyRunoff(1:2192),type='l')
plot(dailyRunoff(1:2192)*(curShedArea-A0)/1000,type='l')
abline(h=V0,col='red')
V0
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)
zmax1
i
UNDERCsheds
UNDERCsheds[i,]
i=21
UNDERCsheds[i,]
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
A0
V0
u0
source("nhldWatershedModel_onlyHydroSupporting.R")
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/NHLD_lakeCmodel")
source("nhldWatershedModel_onlyHydroSupporting.R")
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
dim(out)
dailyRunoff(110:120)*(curShedArea-A0)/1000
V0
source("nhldWatershedModel_onlyHydroSupporting.R")
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
V0
10961071/V0
p
uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V0,Vu=10961071)$root
plot(seq(0,1,0.01),findU(seq(0,1,0.01),p,V0,10961071),type='l')
plot(seq(0,2,0.01),findU(seq(0,2,0.01),p,V0,10961071),type='l')
range(findU(seq(0,2,0.01),p,V0,10961071))
range(findU(seq(0,2,0.01),p,V0,10959474))
range(findU(seq(0,2,0.01),p,V0,10343202))
Vmax
V1
10961071/V1
range(findU(seq(0,2,0.01),p,V1,10343202))
range(findU(seq(0,2,0.01),p,V1,10959474))
range(findU(seq(0,2,0.01),p,V1,10961071))
i=17
source("nhldWatershedModel_onlyHydroSupporting.R")
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
outO=out
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*2.5#
zmax1=zmax0*2.5
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
head(out)
plot(out$stage,outO$stage)
plot(out[,4],outO[,4])
dim(outO)
dim(out)
outN=out
out=outO
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*1.25#
zmax1=zmax0*1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)
dim(outN)
dim(out)
plot(out[,4],outN[,4])
abline(a=0,b=1,col='red')
head(out)
plot(out[,2],out[,3])
points(outN[,2],outN[,3],pch=15,col='red')
zmax1
Amax
u=seq(0,1,0.01)
plot(A=A1*(p*u^2+(1-p)*u),u*zmax1,ylim=c(zmax1,0),type='l')
plot(A1*(p*u^2+(1-p)*u),u*zmax1,ylim=c(zmax1,0),type='l')
plot(A1*(p*u^2+(1-p)*u),u*zmax1,ylim=c(zmax1,0),type='l')
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
zbar1=zbar0*2.5#
zmax1=zmax0*2.5#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))
lines(A1*(p*u^2+(1-p)*u),u*zmax1,col='red')
UNDERCsheds
i=21
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
i=3
UNDERCsheds[i,]
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*1.25#2.5#1.25#
zmax1=zmax0*1.25#2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
source("nhldWatershedModel_onlyHydroSupporting.R")
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*1.25#2.5#1.25#
zmax1=zmax0*1.25#2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
source("nhldWatershedModel_onlyHydroSupporting.R")
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*1.25#2.5#1.25#
zmax1=zmax0*1.25#2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
V1
uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=29989.71)$root
rm(list=ls())#
#
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/NHLD_lakeCmodel")#
#
########## load utility functions and packages#
source("nhldWatershedModel_onlyHydroSupporting.R")#
require(deSolve)#
require(LakeMetabolizer)#
#
######## load forcing and flux data#
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/VICforcings&output/PROC")#
#
cells=gsub("FLUX_","",grep("FLUX",list.files(),value=TRUE))#
#
forceFiles=grep("FORCE",list.files(),value=TRUE)#
fluxFiles=grep("FLUX",list.files(),value=TRUE)#
#
#### UNDERC includes four VIC cells#
# 46.28125_-89.53125#
# 46.28125_-89.46875#
# 46.21875_-89.53125#
# 46.21875_-89.46875#
UNDERCcells=cells[c(169,170,182,183)]#
#
# Lat Long Year Month Day Runoff_mmDay Precip_mmDay EvapOpenWater_mmDay#
flux=read.table(paste("FLUX_",UNDERCcells[1],sep=""),header=FALSE)#
# Lat Long Year Month Day Hour NetLW_Wm2 NetSW_Wm2 LW_Wm2 SW_Wm2 AirTemp_dC atmPress_kPa windspeed_mS@10m relHumid_fraction#
force=read.table(paste("FORCE_",UNDERCcells[1],sep=""),header=FALSE)#
#
# starting year/month/day, ending year/mnth/day, & set up force/flux#
startYear=2008#
startMonth=1#
startDay=1#
#
endYear=2013#
endMonth=12#
endDay=31#
#
curForce=force[which(((force[,3]==startYear) & (force[,4]==startMonth) & (force[,5]==startDay) & (force[,6]==0))):which(((force[,3]==endYear) & (force[,4]==endMonth) & (force[,5]==endDay) & (force[,6]==23))),]#
#
curFlux=flux[which(((flux[,3]==startYear) & (flux[,4]==startMonth) & (flux[,5]==startDay))):which(((flux[,3]==endYear) & (flux[,4]==endMonth) & (flux[,5]==endDay))),]#
#
curFluxDOY=1:nrow(curFlux)#
curForceDOY=rep(curFluxDOY,each=24)#
#
setwd("/Volumes/JonesExternal/External/activeStuff/NHLD_Cmodel/NHLD_lakeCmodel")#
#
###### forcing functions#
dailyPrecip=approxfun(curFluxDOY,curFlux[,7],method="constant")#
dailyEvap=approxfun(curFluxDOY,curFlux[,8],method="constant")#
dailyRunoff=approxfun(curFluxDOY,curFlux[,6],method="constant")#
#
####### ice cover: using regressions from Finland ()#
# -> alternative: try looking at NTL data...; fit model with degree days?#
#
###***** this stuff will have troubles if ice on happens after january 1 ******####
aprilForce=force[force[,4]==4,]#
novForce=force[force[,4]==11,]#
#
aprilAT=tapply(aprilForce[,11],aprilForce[,3],FUN=mean)#
novAT=tapply(novForce[,11],novForce[3],FUN=mean)#
#
iceOnDOY=(novAT+28.8)/0.19+182	#equation for November from inland North -> has latest ice on; pick this one because study area much higher N#
#
iceOffDOY=(aprilAT-49.7)/-0.16+182-365	#Coastal/South model for breakup; again earliest date, but want this bias...#
#
iceON=numeric(nrow(curFlux))#
years=sort(unique(curFlux[,3]))#
for(j in 1:length(years)){#
	curYear=curFlux[curFlux[,3]==years[j],]#
	curDOY=as.numeric(strftime(strptime(paste(curYear[,3],curYear[,4],curYear[,5],sep="-"),format="%Y-%m-%d"),format="%j"))#
	iceON[curFlux[,3]==years[j]]=((curDOY<iceOffDOY[names(iceOffDOY)==years[j]]) | (curDOY>iceOnDOY[names(iceOnDOY)==years[j]]))*1#
}#
#
####### load lake/watershed information#
UNDERCsheds=read.table("../NHLDwatershedDelineations/UNDERCsheds_4-24-15.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)#
#
GFLOWoutput=read.table("../gflowOutput_3-24-15/GFLOWperElementDischarge_4-24-15.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
i=1
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
i
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
i
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
i
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
i
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
i
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
out=cbind(out,NA,NA,NA)#
for(j in 1:nrow(out)){#
	if(!is.na(out[j,2])){#
		uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
		out[j,3]=A1*(p*uj^2+(1-p)*uj)#
		out[j,4]=zmax1*uj#
		out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
	}#
}#
colnames(out)[3:5]=c("A","stage","perim")#
#
C=(2/3)^1.5*9.806^0.5	# m s-2#
L=0.1	# m#
H=out[,4]-stageOut#
QoutSim=ifelse(H>0,(C*L*H^1.5)*(60*60*24),0)#
hydroSumm=cbind(out[,1],dailyRunoff(out[,1])*(curShedArea-out[,3])/1000,dailyPrecip(out[,1])*out[,3]/1000,gwIn0*out[,5]/Perim0,QoutSim,dailyEvap(out[,1])*out[,3]/1000*(1-iceON[1:nrow(out)]),gwOut0*out[,5]/Perim0)#
colnames(hydroSumm)=c("time","Qin","precip","GWin","Qout","evap","GWout")#
#
dev.new()#
par(mfrow=c(3,3))#
plot(hydroSumm[,1],hydroSumm[,2],xlab="time",ylab="Qin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,3],xlab="time",ylab="Precip (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,4],xlab="time",ylab="GWin (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,5],xlab="time",ylab="Qout (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,6],xlab="time",ylab="Evap (m3 d-1)",type='l',lwd=1)#
plot(hydroSumm[,1],hydroSumm[,7],xlab="time",ylab="GWout (m3 d-1)",type='l',lwd=1)#
plot(out[,1],out[,2],xlab="time",ylab="Volume (m^3)",type='l',lwd=1)#
plot(out[,1],out[,4],xlab="time",ylab="stage (m)",type='l',lwd=1)#
meanBudget=colMeans(hydroSumm[,-1],na.rm=TRUE)#
barplot(meanBudget*c(1,1,1,-1,-1,-1),names.arg=names(meanBudget))#
#
avgDailyIn=sum(meanBudget[1:3])#
avgDailyOut=sum(meanBudget[4:6])#
# estimate of residence time#
print(mean(out[,2],na.rm=TRUE)/(mean(c(avgDailyIn,avgDailyOut))))
i
i=21
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
i
i=19
dev.off(); i=i+1; curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
AREAs=matrix(NA,nrow(curFlux),nrow(UNDERCsheds))#
for(i in 1:nrow(UNDERCsheds)){#
	print(i/nrow(UNDERCsheds))#
	curLakeID=UNDERCsheds$Permanent_[i]#
	# current lake and shed parameters#
	A0=UNDERCsheds$NHLD_lakes[i]		#m2#
	V0=10^(-0.0589+1.12963*log10(A0))		#m3#
	Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
	DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
	p=6*DR-3#
	zbar0=V0/A0#
	zmax0=zbar0/DR#
	DL=Perim0/(2*sqrt(pi*A0))#
	# quadratic function peaks and begins to fall again at u=1...#
	#		problem for when lake rises above zmax0#
	#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
	#		have to scale both zmax and zbar to maintain DR#
	#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
	#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
	zbar1=zbar0*2.5#1.25#
	zmax1=zmax0*2.5#1.25#
	uScale=zmax0/zmax1#
	A1=A0/(p*uScale^2+(1-p)*uScale)#
	V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
	curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
	u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
	curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
	curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
	GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
	GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
	gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
	gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
	#### these seem too high; for now just divide GW by 60 to make some progress...#
	gwIn0=gwIn0/60#
	gwOut0=gwOut0/60#
	stage0=u0*zmax1#
	alpha=0.8#
	stageOut=alpha*stage0#
#
	params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
	initialX=c(V=V0)#
	times=curFluxDOY#
	out<-ode(y=initialX,times=times,func=timeStep,parms=params)#
#
	out=cbind(out,NA,NA,NA)#
	for(j in 1:nrow(out)){#
		if(!is.na(out[j,2])){#
			uj=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=out[j,2])$root,4)#
			out[j,3]=A1*(p*uj^2+(1-p)*uj)#
			out[j,4]=zmax1*uj#
			out[j,5]=2*pi*sqrt(out[j,3]/pi)*DL#
		}#
	}#
	colnames(out)[3:5]=c("A","stage","perim")#
	AREAs[,i]=out[,3]#
}#
colnames(AREAs)=UNDERCsheds$GNIS_Name
i
curLakeID=UNDERCsheds$Permanent_[i]#
# current lake and shed parameters#
A0=UNDERCsheds$NHLD_lakes[i]		#m2#
V0=10^(-0.0589+1.12963*log10(A0))		#m3#
Perim0=UNDERCsheds$Perimeter[i]			#******* how to make this dynamic???#
DR=0.45		# going with quadratic because it is simpler and close to 0.5 the two classes are almost identical #
p=6*DR-3#
zbar0=V0/A0#
zmax0=zbar0/DR#
DL=Perim0/(2*sqrt(pi*A0))#
# quadratic function peaks and begins to fall again at u=1...#
#		problem for when lake rises above zmax0#
#		one fix is to set zmax to something higher than value inferred from zbar and DR...#
#		have to scale both zmax and zbar to maintain DR#
#		after this, I think we can solve for Amax and Vmax and use these to scale Au and Vu appropriately...#
#		5-12-15:  in trying UNDERC lakes Tenderfoot "overflows"  can bump this multiplier from 1.25 to 2.5 -> this changes stage dynamics and model behavior a bit because stage and Area at a given Volume are slightly different#
zbar1=zbar0*2.5#1.25#
zmax1=zmax0*2.5#1.25#
uScale=zmax0/zmax1#
A1=A0/(p*uScale^2+(1-p)*uScale)#
V1=V0/((6*uScale-3*(1-p)*uScale^2-2*p*uScale^3)/(3+p))#
curShedArea=UNDERCsheds$Area_m2[i]	#m2#
#
u0=round(uniroot(f=findU,lower=0,upper=1,p=p,Vmax=V1,Vu=V0)$root,4)#
curGFLOW=GFLOWoutput[GFLOWoutput$Permanent_==curLakeID,]#
curGFLOW=curGFLOW[!is.na(curGFLOW$Permanent_),]#
GFLOWpropPerim=curGFLOW$Linesink_Length_Output/sum(curGFLOW$Linesink_Length_Output)#
GFLOWin=(curGFLOW$Linesink_PerLengthDischarge_Output>0)*1#
gwIn0=sum(GFLOWin*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
gwOut0=-sum((1-GFLOWin)*curGFLOW$Linesink_PerLengthDischarge_Output*GFLOWpropPerim*Perim0)*0.0283168	#m3 d-1#
#### these seem too high; for now just divide GW by 60 to make some progress...#
gwIn0=gwIn0/60#
gwOut0=gwOut0/60#
stage0=u0*zmax1#
alpha=0.8#
stageOut=alpha*stage0#
#
params=c(Vmax=V1,Zmax=zmax1,Amax=A1,curShedArea=curShedArea,stageOut=stageOut,Perim0=Perim0,gwIn0=gwIn0,gwOut0=gwOut0,p=p,DL=DL)#
#
initialX=c(V=V0)#
times=curFluxDOY#
out<-ode(y=initialX,times=times,func=timeStep,parms=params)
dim(out)
i
UNDERCsheds[i,]
